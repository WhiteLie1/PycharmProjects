字符串和编码
Python数据类型：
1.整数，可以处理任意大小的整数
2.浮点数，整数永远是精确的，浮点数可能有四舍五入
3.字符串
>>> print('I\'m \"OK\"!')
I'm "OK"!
请注意转义字符的使用！ \
转义字符\可以转义很多字符，比如\n表示换行，
\t表示制表符，字符\本身也要转义，所以\\表示的字符就是\，
可以在Python的交互式命令行用print()打印字符串看看：
4.布尔值 布尔值只有 True和 False 两种值，注意大小写
5.空值 空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。
此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型
6.常量。所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量
你没有看错，整数的地板除//永远是整数，即使除不尽。要做精确的除法，使用/就可以。
/除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：

小结
Python支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。
对变量赋值x = y是把变量x指向真正的对象，该对象是变量y所指向的。随后对变量y的赋值不影响变量x的指向。
注意：Python的整数没有大小限制

数据类型和编码
在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。
用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件

对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：
>>> ord('A')
65
注意区分'ABC'和b'ABC'，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。
以Unicode表示的str通过encode()方法可以编码为指定的bytes，
反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法
要计算str包含多少个字符，可以用len()函数：
len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：
1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。
由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

格式化输出的问题:
%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?,括号可以省略

占位符	替换内容
%d	整数
%f	浮点数
%s	字符串
%x	十六进制整数

字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%：
>>> 'growth rate: %d %%' % 7
'growth rate: 7 %'

另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多：
>>> 'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125)
'Hello, 小明, 成绩提升了 17.1%'

小结
Python 3的字符串使用Unicode，直接支持多语言。
当str和bytes互相转换时，需要指定编码。最常用的编码是UTF-8。Python当然也支持其他编码方式，比如把Unicode编码成GB2312：
>>> '中文'.encode('gb2312')
b'\xd6\xd0\xce\xc4'
但这种方式纯属自找麻烦，如果没有特殊业务要求，请牢记仅使用UTF-8编码。
格式化字符串的时候，可以用Python的交互式环境测试，方便快捷。


list和tuple
list：是Python内置的一种数据类型，列表。是一种有序的集合，可以随时添加和删除其中的元素
>>> classmates = ['ma','ad','dsaf']
>>> classmates
['ma', 'ad', 'dsaf']
变量classmates就是一个list。用len()函数可以获得list元素的个数：
用索引来访问list中每一个位置的元素，记得索引是从0开始的
当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，记得最后一个元素的索引是len(classmates) - 1

list是一个可变的有序表，所以，可以往list中追加元素到末尾：
>>> classmates.append('chenxin')
>>> print(classmates)
['ma', 'ad', 'dsaf', 'chenxin']

也可以把元素插入到指定的位置，比如索引号为0的位置：
>>> classmates.insert(0,'lisi')
>>> print(classmates)
['lisi', 'ma', 'ad', 'dsaf', 'chenxin']

删除list末尾的元素，用pop()方法
>>> classmates.pop()
'chenxin'

要删除指定位置的元素，用pop(i)方法，其中i是索引位置：

要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：

list里面的元素的数据类型也可以不同，比如：
>>> L = ['Apple', 123, True]
list元素也可以是另一个list，比如：
>>> s = ['python', 'java', ['asp', 'php'], 'scheme']

tuple
另外一种有序数列叫做元组:tuple和list非常类似，但是，tuple一旦初始化就不能修改
>>> classmates = ('Michael', 'Bob', 'Tracy')

最后来看一个“可变的”tuple：
>>> t = ('a', 'b', ['A', 'B'])
>>> t[2][0] = 'X'
>>> t[2][1] = 'Y'
>>> t
('a', 'b', ['X', 'Y'])
面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变

条件判断：
if <条件判断1>:
    <执行1>
elif <条件判断2>:
    <执行2>
elif <条件判断3>:
    <执行3>
else:
    <执行4>
if语句执行有个特点，它是从上往下判断，如果在某个判断上是True，把该判断对应的语句执行后，就忽略掉剩下的elif和else

if x:
    print('True')
只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False。
最后看一个有问题的条件判断。很多同学会用input()读取用户的输入，

这是因为input()返回的数据类型是str，str不能直接和整数比较，必须先把str转换成整数。Python提供了int()函数来完成这件事情：
input返回类型为 str!
s = input('birth: ')
birth = int(s)
if birth < 2000:
    print('00前')
else:
    print('00后')

循环：
Python的循环有两种，一种是for...in循环，依次把list或tuple中的每个元素迭代出来，看例子

names = ['Michael', 'Bob', 'Tracy']
for name in names:
    print(name)

如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个range()函数，
可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数

小结
循环是让计算机做重复任务的有效的方法。
break语句可以在循环过程中直接退出循环，而continue语句可以提前结束本轮循环，并直接开始下一轮循环。这两个语句通常都必须配合if语句使用。
要特别注意，不要滥用break和continue语句。break和continue会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到break和continue语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉break和continue语句。

使用 dict 和 set:
python内置字典：dic的支持
>>> d = {'a':78,'b':99}
>>> d['a']
78
格式 d = {}
把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：
>>> d['a']=996
>>> d['a']
996
由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：
如果key不存在，dict就会报错：
>>> d['sd']
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'sd'
要避免key不存在的错误，有两种办法，一是通过in判断key是否存在：
>>> 'sd' in d
False
二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value：
注意：返回None的时候Python的交互环境不显示结果。

要删除一个key，用pop(key)方法，对应的value也会从dict中删除：
>>> d.pop('a')
996

请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。
和list比较，dict有以下几个特点：
查找和插入的速度极快，不会随着key的增加而变慢；
需要占用大量的内存，内存浪费多。
而list相反：
查找和插入的时间随着元素的增加而增加；
占用空间小，浪费内存很少。

所以，dict是用空间来换取时间的一种方法。

dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。
这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。
要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key

set
set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。
s = set([1,2,3])
重复元素在set中自动被过滤

>>> s = set([1,3,4])
>>> s = set([1,3,4,2,2,3,4,4,4])
>>> s
{1, 2, 3, 4}

通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果：
通过remove(key)方法可以删除元素：
>>> s.remove(1)
>>> s
{2, 3, 4}

set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作
>>> s1 = set([1,2,3])
>>> s2 = set([2,3,4])
>>> s1 & s2
{2, 3}

set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错
>>> s3 = set([classmates])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'

排序：
>>> a = ['c','b','a']
>>> a.sort()
>>> a
['a', 'b', 'c']
而对于不可变对象，比如str，对str进行操作呢
>>> a = 'abc'
>>> b = a.replace('a','A')
>>> a
'abc'
>>> b
'Abc'
分析问题：
>>> a = 'abc'
>>> b = a.replace('a', 'A')
>>> b
'Abc'
>>> a
'abc'
要始终牢记的是，a是变量，而'abc'才是字符串对象！有些时候，我们经常说，对象a的内容是'abc'，但其实是指，a本身是一个变量，它指向的对象的内容才是'abc'：
当我们调用a.replace('a', 'A')时，实际上调用方法replace是作用在字符串对象'abc'上的，而这个方法虽然名字叫replace，但却没有改变字符串'abc'的内容。相反，replace方法创建了一个新字符串'Abc'并返回，如果我们用变量b指向该新字符串，就容易理解了，变量a仍指向原有的字符串'abc'，但变量b却指向新字符串'Abc'了

所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。


