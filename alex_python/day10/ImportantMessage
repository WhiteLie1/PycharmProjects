失控 kk,必然
浪潮之巅，数学之美，消费者行为学

线程 vs 进程

线程： 内存共享
线程同时修改同一份数据时必须加锁，mutex互斥锁
递归锁


t_res = []
def run():
    print("run thread...")

for i in range(10):
    t = threading.Thread(target=run,args=(n,))
    t.setDaemon(True)
    t.start()
    t_res.append(t)
for r in t_res:

    r.join()

print"master is done...!"




A
    B
        C
            D
join等待一个线程的结束

守护线程（slave）服务于非守护线程
进程: 至少包含一个线程

queue
    解耦合 ，使程序之间松耦合
    提高处理效率，
    生产者消费者之间就是使用队列来解耦


    FIFO = first in first out
    LIFO = last in first out

IO操作不占用CPU
计算占用CPU，1+1
python多线程，不适合CPU密集操作型的任务，适合IO操作密集型的任务

协程

协程，又称微线程，纤程。英文名Coroutine。一句话说明什么是线程：协程是一种用户态的轻量级线程。

协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：

协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。
协程的好处：

    无需线程上下文切换的开销
    无需原子操作锁定及同步的开销
        　　"原子操作(atomic operation)是不需要synchronized"，所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序是不可以被打乱，或者切割掉只执行部分。视作整体是原子性的核心。
    方便切换控制流，简化编程模型
    高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。



缺点：

    无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。
    进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序

论事件驱动与异步IO
通常，我们写服务器处理模型的程序时，有以下几种模型：
（1）每收到一个请求，创建一个新的进程，来处理该请求；
（2）每收到一个请求，创建一个新的线程，来处理该请求；
（3）每收到一个请求，放入一个事件列表，让主进程通过非阻塞I/O方式来处理请求
上面的几种方式，各有千秋，
第（1）中方法，由于创建新的进程的开销比较大，所以，会导致服务器性能比较差,但实现比较简单。
第（2）种方式，由于要涉及到线程的同步，有可能会面临死锁等问题。
第（3）种方式，在写应用程序代码时，逻辑比前面两种都复杂。
综合考虑各方面因素，一般普遍认为第（3）种方式是大多数网络服务器采用的方式

multiprocess
Queue\Pipe 只是实现进程间数据的传递
Manager实现了数据的共享，即多个进程可以修改同一份数据

IO 多路复用
缓存 I/O 的缺点：
数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，
这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。

